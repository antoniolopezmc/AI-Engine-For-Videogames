%--------------------------------------------------------------------
\medskip
\section{Modelo}

Esta es una de las partes más importantes del videojuego, puesto que en ella podemos encontrar a los \textbf{agentes} que intervendrán e interactuarán en el transcurso del juego. Concretamente, en este paquete podemos encontrar la implementación de los objetos del mundo (concepto general que lo engloba todo), la implementación de los personajes, la implementación de los obstáculos y la implementación de las formaciones (que han sido tratadas como un tipo especial de personaje).

\subsection{Clase WorldObject}

La clase \texttt{WorldObject} es un concepto general que representa a una entidad del juego. Todas las entidades concretas (descritas en los siguientes subapartados) heredarán de esta \textbf{clase abstracta}. Una cosa muy importante a tener en cuenta es que esta clase abstracta hereda a su vez de la clase \texttt{Sprite} de la librería libgdx. Esto se ha hecho así para aprovechar todas las características y propiedades que ya posee la clase \texttt{Sprite}, como por ejemplo, la posición, la orientación, la anchura, la altura, las funciones de dibujo u otra funcionalidad ya preprogramada en la librería. \\

Solamente hay que tener en cuenta una cosa muy importante: a lo que nosotros llamamos orientación, la librería lo llama rotación. Esto a su vez puede llevar a confusiones con la velocidad angular (que para nosotros es la rotación). Para evitar todos estos problemas de nomenclatura y todas las confusiones que esto pueda provocar, se han tomado ciertas medidas:

\begin{itemize}
	\item[-] Se han creado el par de funciones \texttt{getOrientation} y \texttt{setOrientation} que llaman a las funciones correspondiente del padre (\texttt{super.getRotation} y \texttt{super.setRotation}).
	\item[-] Se han sobrescrito las funciones \texttt{getRotation} y \texttt{setRotation} heredadas del padre para que si se llaman en el hijo (en la clase \texttt{WorldObject}), lancen una excepción. Estas funciones no se deben llamar nunca, puesto que si deseamos consultar o modificar la orientación de una entidad, deberemos hacer uso de las funciones \texttt{getOrientation} y \texttt{setOrientation} de la clase \texttt{WorldObject}.
\end{itemize}

Estas modificaciones solucionan el problema y evitan que se puedan producir confusiones con los nombres y errores de concepto a lo largo del resto del proyecto. \\

En cuanto a los atributos propios de la clase \texttt{WorldObject} (los no heredados de la clase \texttt{Sprite}), podemos encontrar la velocidad del \texttt{WorldObject} (vector velocidad de tipo \texttt{Vector3}), la velocidad angular del \texttt{WorldObject} (escalar de tipo float) y la velocidad máxima del \texttt{WorldObject} (escalar de tipo float que hace referencia a la máxima velocidad que puede tener independientemente de su comportamiento). Este último atributo se ve reflejado en el método \texttt{setVelocity}. Si el módulo del vector que se pasa como parámetro supera a la velocidad máxima permitida, entonces el vector velocidad que se asigna al \texttt{WorldObject} es un vector con la misma dirección y sentido que el pasado como parámetro, pero con un módulo igual al atributo \texttt{maxSpeed} (máxima velocidad permitida del \texttt{WorldObject}). \\

Cabe destacar que el método de dibujo de la textura del \texttt{WorldObject} ha cambiado. Por defecto, la librería libgdx dibuja la textura de tal manera que la esquina inferior izquierda de ésta es la posición del sprite. Sin embargo, lo que nosotros queremos es que la posición del sprite corresponda con \textbf{el centro} de la textura. Por ese motivo, el método \texttt{draw} de la clase \texttt{Sprite} ha sido sobrescrito en la clase \texttt{WorldObject}. Antes de proceder al dibujo de la textura, la posición del \texttt{WorldObject} se modifica temporalmente, de tal manera que el centro de la textura corresponda con la posición real del \texttt{WorldObject}. Tras dibujar la textura, la posición vuelve a restablecerse. Para conseguir esto, basta con restar a la coordenada 'x' e 'y' del \texttt{WorldObject} la mitad de la anchura y la mitad de la altura respectivamente.


\subsection{Clase Character}
\label{clase-personaje}

La clase \texttt{Character} representa a un personaje del videojuego y hereda de la clase \texttt{WorldObject}. En esta clase podemos encontrar ciertos atributos propios como la lista de comportamientos del personaje, la formación a la que pertenece el personaje (si no pertenece a ninguna, este atributo es \texttt{null}) y el árbitro que gestiona la lista de comportamiento del personaje y selecciona el steering final a aplicar (se describe con más detalle es la sección correspondiente). Cabe destacar que este último atributo es obligatorio. Todos los personajes deben tener un árbitro que selecciona el steering final a aplicar. \\

La lista de comportamientos es realmente un \texttt{Map} en el que se almacenan parejas formadas por el comportamiento propiamente dicho y un valor de tipo float que representa la importancia de ese comportamiento dentro de la lista. Este valor de importancia puede significar distintas cosas en función del árbitro que se esté usando (esto se detallará más en la sección correspondiente). En cualquier caso y si no se indica lo contrario, el comportamiento se añade con una valor por defecto que viene dado por la constante \texttt{DEFAULT\_IMPORTANCE} presente en esta clase. \\

Además de lo anterior, en la clase \texttt{Character} también podemos encontrar otros métodos relevantes como el método \texttt{getNewOrientation}, que dado un steering devuelve la orientación final del personaje tras la aplicación de dicho steering (solo para steerings no acelerados); el método \texttt{applyBehaviour}, que llama al árbitro para obtener un steering y aplica dicho steering mediante el método \texttt{applySteering}; el método \texttt{applySteering}, que aplica el steering que se le pasa como parámetro (llama al método \texttt{update} solo si el personaje actual no forma parte de una formación); y el método \texttt{update}, que es el que realmente aplica el steering pasado como parámetro, modificando las propiedades del personaje. Este último método comprueba si el steering pasado como parámetro es de tipo uniforme o uniformemente acelerado y actúa en consecuencia. \\

Una cosa importante a destacar es que \textbf{si una entidad pertenece a una formación, no se podrá mover libremente}, es decir, da exactamente igual la lista de comportamientos que tenga, ya que ninguno influirá sobre él. Una entidad perteneciente a una formación se moverá acorde con la formación. Esto se explica más en detalle en el apartado correspondiente.

\subsection{Clase Obstacle}

La clase \texttt{Obstacle} representa a un obstáculo fijo y, al igual que la anterior, hereda de la clase \texttt{WorldObject}. La única peculiaridad que tiene esta clase es que todos los métodos como \texttt{getVelocity}, \texttt{getSpeed} o \texttt{setRotation\_angularSpeed}, entre otros, están sobrescritos para que se devuelvan 0 o el vector 0. Esto es así porque, como acabo de comentar, esta clase representa obstáculos estáticos que no se mueven.

\subsection{Formaciones}
\label{formaciones}

La \textbf{clase abstracta} \texttt{Formation} representa a un conjunto de personajes organizados en formación. Hemos planteado el tema de las formaciones de tal manera que heredan de la clase \texttt{Character}, es decir, las formaciones son un tipo especial de personaje. Además, en la clase \texttt{Formation} se hace uso del \textbf{patrón composite}, lo que va a permitir que uno de los integrantes de una formación pueda ser a su vez otra formación. Esto quiere decir que \textbf{se pueden construir formaciones de formaciones todo lo grandes y profundas que deseemos} (con todos los niveles de profundidad que deseemos). De esta clase heredarán todos los tipos de formaciones concretas que se deseen crear. \\

Además de los atributos heredados del padre, esta clase dispone de algunos atributos propios como la lista de personajes que pertenecen a la formación y la orientación que adoptarán los componentes de la formación. En cuanto al segundo atributo, hay diversas opciones: orientación libre, que todos los componentes miren hacia el interior de la formación, que todos los componentes miren hacia el exterior de la formación o que todos los componentes adopten la misma orientación que la formación (la misma orientación que el objeto \texttt{Formation}). \\

A parte del patrón composite, en esta clase también se ha aplicado el \textbf{patrón método plantilla}. Podemos observar este patrón en los métodos \texttt{getCharactersPosition} y \texttt{getComponentFormationSteerginToApply} (la implementación de ambos métodos se delega a los hijos de la clase \texttt{Formation}). El primer método sirve para calcular y obtener las posiciones \textbf{con respecto al centro o ancla de la formación} que ocuparán los integrantes de la misma. El segundo método sirve para obtener el steering que será aplicado sobre un componente de la formación. \\

La implementación del patrón composite se ve reflejada en el método \texttt{applySteering} (este método ha sido sobrescrito). Mientras que en el padre (clase \texttt{Character}), simplemente se llamaba al método \texttt{update}, en esta ocasión se realizan las siguientes acciones (solo si la formación no pertenece a otra formación):
\begin{itemize}
	\item[-] En primer lugar, se aplica el método \texttt{update} sobre la formación, lo que provocará que el objeto formación (el ancla) se mueva según el steering concreto pasado como parámetro.
	\item[-] A continuación, se calculan las posiciones que ocuparán cada uno de los integrantes de la formación. Para ello, ejecutamos el método \texttt{getCharactersPosition}. Cabe destacar que la lista de posiciones obtenida \textbf{tendrá la misma longitud que la lista de integrantes de la formación}.
	\item[-] Seguidamente, se recorre cada componente de la formación y se aplican las siguientes acciones:
	\begin{itemize}
		\item[*] Se indica momentáneamente que el componente actual no pertenece a ninguna formación. Esto debe hacerse para poder aplicarle un steering y, por tanto, poder aplicarle un movimiento.
		\item[*] A continuación, se construye un \texttt{WorldObject} ficticio cuya posición es la posición destino del componente actual de la formación (una de las que han sido calculadas anteriormente).
		\item[*] Seguidamente, se llama al método \texttt{getComponentFormationSteerginToApply} para obtener el steering a aplicar sobre el componente actual de la formación y \textbf{se ejecuta el método} \texttt{applySteering} \textbf{con el steering que se acaba de calcular}. En este paso es donde se puede observar claramente la aplicación del patrón composite. Gracias a esta llamada, conseguimos ``mover en profundidad'' todo lo que haya en la formación.
		\item[*] Finalmente, volvemos a indicar que el componente actual pertenece a una formación, lo que evitará que se pueda mover o manipular desde otro sitio (mientras siga estando en una formación).
	\end{itemize}
\end{itemize}

Al igual que pasaba en el padre, este método se sigue llamando desde \texttt{applyBehaviour}. \\

A parte de todo lo anterior, en esta clase podemos encontrar un método llamado \texttt{drawFormationPoints}. Este método recibe un \textit{renderer} como parámetro y dibuja en él las posiciones que deben ocupar los componentes de la formación. \\

A parte de la clase abstracta \texttt{Formation}, se han implementado diversos tipos de formaciones concretas como formación en circulo, formación en estrella y formación en linea. Tal y como se ha comentado anteriormente, debido a la utilización del método plantilla, cada uno de los tipos concretos de formación deben implementar los métodos \texttt{getCharactersPosition} y \texttt{getComponentFormationSteerginToApply}. \\

Hay diversas cuestiones a tener en cuenta en algunos tipos de formaciones concretas implementadas:
\begin{itemize}
	\item La formación es estrella es un tipo de formación en círculo (hereda de la clase correspondiente a la formación en circulo), en la que ciertos componentes poseen un mayor desplazamiento con respecto al sitio que deberían ocupar en una formación normal en círculo. Además, para que una formación en estrella pueda crearse se deben cumplir ciertas condiciones: que la cantidad de integrantes sea mayor estricto que 3 y que la cantidad de integrantes sea par. Si estas condiciones no se cumplen, los componentes formarán un círculo normal.
	\item En la formación en linea, el ángulo que forma la linea de componentes está directamente relacionado con la orientación de la propia formación (del objeto formación). Por ese motivo, como en algunos casos la orientación de un \texttt{WorldObject} pueda cambiar y oscilar muy rápidamente y bruscamente, no resulta adecuado que el ángulo de la linea de componentes sea igual a la orientación del \texttt{WorldObject}, puesto que las posiciones finales de los componentes cambiarían bruscamente y rápidamente y la organización de la formación en línea nunca se llevaría a cabo. La solución a este problema ha sido partir el rango de orientaciones del \texttt{WorldObject} en subrangos y asignar a cada subrango un valor del ángulo de la linea de componentes de la formación. Con esto conseguimos que las pequeñas modificaciones de la orientación del objeto \texttt{LineFormation} no afecten a las posiciones finales de los componentes de una formación en línea.
\end{itemize}

A la hora de calcular el steering concreto a aplicar sobre cada uno de los componentes de la formación (en la función \texttt{getComponentFormationSteerginToApply}), también se hace uso de un árbitro y de una lista de comportamientos. \textbf{Es muy importante no confundir estos elementos con el árbitro y la lista de comportamientos del padre}. En la función \texttt{getComponentFormationSteerginToApply} se declaran y se usan ambos elementos ``a pelo'', puesto que se llegó a la conclusión de preconfigurar y fijar los comportamientos de los componentes de las formaciones y sólo permitir la libre configuración de la lista de comportamientos de la propia formación. Esto se debe a que realmente, lo que se mueve es la formación y los componentes de ésta deben limitarse a ir a los puntos que han sido calculados para ellos.

