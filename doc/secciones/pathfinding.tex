%--------------------------------------------------------------------
\medskip
\section{PathFinding}

Tras haber implementado todos los comportamientos y tipos de movimientos que se pueden aplicar a los personajes de nuestro videojuego, es también muy importante contar con un mecanismo que nos permita obtener el camino adecuado para llegar desde un origen a un destino en función de distintos criterios y teniendo en cuenta cierta información del entorno. Dicho mecanismo se denomina \textit{PathFinding} y es un elemento muy importante en aquellos videojuegos en los que sea necesario (aunque, como también se ha visto en clase, otros videojuegos no lo necesitan, por lo que no lo implementan). \\

El mecanismo de PathFinding visto en clase se apoya fundamentalmente en 2 estructuras. Por un lado, es totalmente imprescindible la matriz de costes de terrero. Esta estructura es un grid ficticio que se sitúa sobre el mapa físico y en el que se almacenan los costes del terreno del mapa del juego. Por otro lado, también se necesita una matriz de distancias o heurística. En esta matriz se almacenan los costes desde cada una de las celdas hasta una celda objetivo. Ambas matrices deben tener las mismas dimensiones. \\

Es muy importantes destacar la existencia de 2 tipos de posiciones con las que vamos a trabajar. Por un lado, tenemos la posición real de una entidad en el mapa y, por otro lado, dicha entidad también tendrá una posición en el grid (esta posición indica \textbf{los índices} de la matriz que representa al grid). Esta segunda posición es con la que trabaja el PathFinding. Teniendo esto en cuenta, habrá que contar con las funciones necesarias para pasar de un tipo de posición a otro. \\

A la hora de pasar una posición del mapa a una posición del grid, entre otras cosas, se eliminan los decimales para poder obtener una posición entera (para usar como índice en el grid ficticio). Por tanto, se podría decir que el mecanismo de búsqueda está basado en un \textbf{grid cuadrado por vértices}. Sin embargo, cuando volvemos a convertir de una posición del grid a una posición del mapa, nos interesa que el movimiento se realice por el centro del tile para evitar que el personaje se mueva justo por la separación entre un tipo de terreno y otro (justo entre un tile y otro). Por tanto, una de las cosas que se hace al transformar de una posición del grid a una posición del mapa es \textbf{sumar la mitad del lado de un tile a ambas coordenadas de la posición final}. De esta forma conseguimos que los puntos finales del mapa siempre estén en el centro de los tiles que representan el terreno. \\

Para este proyecto, hemos implementado \textbf{2 tipos de Pathfinding}. Ambos se basan en el algoritmo LRTA* con espacio de búsqueda minimal. La diferencia fundamental entre ambos es que uno calcula todos los punto de golpe desde el origen al destino (pathfinding continuo) y el otro va devolviendo punto por punto y va calculando un nuevo punto cada vez que sea necesario (pathfinding punto a punto). El primero de ellos devuelve una lista completa con todos los puntos desde el origen hasta el destino y basta con ejecutarlo tan solo una vez. El segundo de ellos devuelve un único punto (aunque también en una lista) y debe ser ejecutado cada vez que queramos obtener el siguiente punto al que ir. Esto se explicará más detalladamente en el apartado correspondiente.

\subsection{Distancias}

Tal y como se ha comentado en clase, las heurísticas que se han implementado son: \textbf{distancia de Manhattan}, \textbf{distancia de Chebyshev} y \textbf{distancia Euclídea}. La información concreta y la forma de cálculo de cada una de estas distancias se especifica detalladamente en las transparencia de la asignatura. \\

En le código fuente de nuestro proyecto podemos encontrar la interfaz \texttt{Distance}. Esta interfaz sirve para generalizar todos los tipos de distancia concretos y tratarlos de manera homogénea. El método fundamental de todas las distancias implementadas es \texttt{getMatrixOfDistances}. Este método recibe las dimensiones que deberá tener la matriz de salida y la posición objetivo y devuelve la matriz de distancias correspondiente. \\

A la hora de realizar un PathFinding desde un origen hasta un destino, la posición objetivo que se le pasa al método \texttt{getMatrixOfDistances} es la posición destino a la que queremos llegar. Esto quiere decir que la matriz de distancias calculada almacenará la distancia desde todas las posiciones del grid a la posición destino a la que queremos llegar (posición destino \textbf{del grid}).

\subsection{Algoritmo LRTA*}

Tal y como se dice en la especificación de estas prácticas, se debe implementar el algoritmo LRTA* con espacio de búsqueda minimal. Eso quiere decir que el espacio de búsqueda solamente estará compuesto por el estado actual en el que nos encontramos. \\

Para el caso del pathfinding continuo, el algoritmo LRTA* recibe como entrada la matriz de costes del terreno, la matriz de distancias (que será distinta según la heurística elegida), la anchura y altura de ambas matrices, la posición origen \textbf{del grid} y la posición destino \textbf{del grid}. Para el caso del pathfinding punto a punto no se recibirá la posición inicial, sino que cada vez que lo llamemos le pasaremos la posición actual desde la que queremos obtener el siguiente punto (que, efectivamente, al principio será el punto de origen). El algoritmo LRTA* trabajará (modificará) sobre la matriz de distancias y devolverá una lista de puntos que corresponden con todas aquellas posiciones \textbf{del grid} por las que hay que pasar para llegar desde el origen hasta el destino (para el caso de pathfinding continuo) o, directamente, el siguiente punto al que debemos ir (para el caso de pathfinding punto a punto). En este segundo caso, obviamente, el algoritmo no realiza ningún bucle. \\ 

Para calcular la función \textit{f(x)} de un estado concreto, serán necesarios los siguientes elementos:
\begin{itemize}
	\item[-] El coste que supone realizar una acción (movernos de una celda a otra). Este valor viene definido por la constante \texttt{default\_action\_cost} de la clase \texttt{LRTA\_star}.
	\item[-] La distancia que hay desde en estado actual hasta la posición de destino. Este valor podemos obtenerlo de la matriz de distancias.
	\item[-] El coste del terreno en la posición o estado actual en el que nos encontramos.
\end{itemize}

Estos componentes serán la base para obtener el valor de la función \textit{f(x)} de un estado concreto y, por tanto, para que el algoritmo LRTA* calcule el camino adecuado desde un origen hasta un destino. \\

Además, también se han implementado diversos método necesarios para el correcto funcionamiento del algoritmo LRTA*. El primero de ellos es \texttt{generateSuccessors}. Este método recibe una posición del grid y devuelve todos sus vecinos (tanto en horizontal, como en vertical, como en diagonal). El segundo método necesario es \texttt{getSuccessorWithTheSmallestHeuristic}. Este método selecciona el vecino tal que \textit{f(x)} devuelva el menor valor.

\subsection{Clase PathFinding}

Esta es la clase principal del mecanismo de PathFinding. Al igual que ocurre con el propio algoritmo LRTA*, cada tipo de pathfinding implementado tiene su propia clase y lo implementa de distinta forma. Las particularidades de cada uno se comentarán en las siguientes secciones.

\subsubsection{Pathfinding continuo}

En este pathfinding el método \texttt{applyPathFinding} es el encargado de realizar la conversión de posiciones del mapa a posiciones del grid (y viceversa) y de la ejecución del algoritmo LRTA*. En este caso, la función \texttt{applyPathFinding} devolverá el resultado final (lista con todos los puntos) tras la primera ejecución y, si queremos volver a hacer un pathfinding, deberemos crear y comenzar de nuevo. Este método recibe como parámetro la matriz de costes del terreno, la heurística deseada, el tamaño del lado de celda del grid, la anchura y altura de las matrices, las coordenadas 'x' e 'y' \textbf{del mapa} del origen y las coordenadas 'x' e 'y' \textbf{del mapa} del destino. \\

En primer lugar, las coordenadas del mapa son transformadas en coordenadas del grid; seguidamente, se calcula la matriz de distancias; a continuación, se ejecuta el algoritmo LRTA*; y finalmente, se vuelven a transformar todas las coordenadas del grid al mapa (de todos los puntos que ha devuelto el algoritmo LRTA*). \\

Cabe destacar que al transformar las coordenadas del mapa de los puntos origen y destino a coordenadas del grid se pierde información, puesto que las coordenadas del mapa son de tipo \texttt{float} (con decimales) y las coordenadas del grid no tienen decimales (puesto que estas coordenadas son realmente los indices con los que se accederán a ambas matrices). Por este motivo, al volver a transformar las coordenadas del grid al mapa, se realiza también una segunda transformación. El primer y último punto de la lista que devuelve el algoritmo LRTA* (el origen y destino), son reemplazados por las coordenadas originales que se pasaron como parámetro a la función \texttt{applyPathFinding}.

\subsubsection{Pathfinding punto a punto}

Al contrario que pasaba con el pathfinding anterior, en este caso el constructor de la clase juega un papel más importante. En este caso, es en el constructor donde se almacenan todos los atributos necesarios (según los parámetros pasados al constructor) y donde se realiza la transformación de la coordenada inicial del pathfinding de coordenadas del mapa a coordenadas del grid. Además, puesto que en esta ocasión el pathfinding va a ser llamado más de una vez (cosa que no pasaba en el pathfinding anterior), en el constructor también se crea el objeto que representa el algoritmo LRTA* y se almacena como un atributo de la clase (para ir usando siempre el mismo objeto y no perder el avance realizado). \\

Un elemento fundamental en este tipo de pathfinding es el atributo \texttt{objetivoActual}. Inicialmente, este atributo contiene el punto de partida del pathfinding y, conforme vayamos avanzando, iremos actualizando este atributo con la posición a la que debemos ir. Este caso, el pathfinding punto a punto irá devolviendo siempre la misma posición hasta que no lleguemos a ella (ver las comprobaciones iniciales del método \texttt{applyPathFinding}). Una vez que el personaje haya alcanzado el siguiente objetivo actual, el pathfinging y el algoritmo LRTA* continuarán calculando.

\subsection{Pathfinding táctico}

Para añadir información táctica al pathfinding es suficiente con tener en cuenta el valor de la matriz de influencia (o cualquier otra información que queramos añadir) en el cálculo de la función f(x) en el algoritmo LRTA*. La utilización de información táctica se puede activar o desactivar sobre la marcha. Para ello, hemos añadido los flags correspondientes en las clases del pathfinding y del algoritmo LRTA* y las funciones necesarias para activar y desactivar dichos flags. \\

Concretamente, nuestro pathfinding táctico podrá usar la información táctica proveniente del mapa de influencia y la información táctica propia de cada rol. Dicha información táctica en relación a cada rol concreto se puede encontrar en el método \texttt{getTacticalCost} de las clases \texttt{Archer} y \texttt{Soldier}. Cada rol concreto podrá tener un coste diferente según cada uno de los terrenos presentes en el mapa.
